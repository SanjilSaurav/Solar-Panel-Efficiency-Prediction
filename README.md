# 🌞 Solar Panel Efficiency Prediction

This project uses **Machine Learning** to predict the efficiency of solar panels based on environmental and operational data. The solution leverages the **CatBoost** algorithm for accurate predictions and provides an end-to-end pipeline including data preprocessing, model training, and serving predictions through an application interface.

---

## 📌 Project Overview

- Perform exploratory data analysis (EDA) on solar panel datasets.
- Train predictive models using **CatBoost**.
- Generate predictions for unseen test data.
- Provide a simple interface (`app.py`) to serve predictions.
- Maintain modular code in the `src/` directory for reusability.

---

## 📂 Repository Structure
├── Documents/ # Project documentation/notes 

├── artifacts/ # Stored trained models & artifacts 

├── catboost_info/ # CatBoost training metadata

├── src/ # Source code (data processing, training, utils)

├── app.py # Application for serving predictions

├── requirements.txt # Python dependencies

├── train.csv # Training dataset

├── test.csv # Test dataset

├── sample_submission.csv # Template for submission format

├── submission_result.csv # Generated predictions

└── zelestra.ipynb # Jupyter Notebook (EDA & modeling)


---

## 📊 Dataset Details

The dataset contains environmental, operational, and diagnostic features of solar panels. These influence panel performance and efficiency.  

### Files:
- **train.csv** → Used for training the model (includes features + target `efficiency`).  
- **test.csv** → Used for generating predictions (features only, no target).  
- **sample_submission.csv** → Example format for output file.  
- **submission_result.csv** → Predictions generated by the trained model.  

### Columns:

| Column Name         | Description                                                                 |
|---------------------|-----------------------------------------------------------------------------|
| **id**              | Unique identifier for each row.                                             |
| **temperature**     | Ambient air temperature (°C), affects panel output efficiency.              |
| **irradiance**      | Solar energy received per unit area (W/m²), directly impacts energy output. |
| **humidity**        | Moisture content in air (%), may impact panel performance over time.        |
| **panel_age**       | Age of the solar panel in years (older panels degrade in performance).      |
| **maintenance_count** | Number of recorded maintenance activities.                               |
| **soiling_ratio**   | Efficiency reduction due to dust/debris on surface (0.0–1.0).               |
| **voltage**         | Voltage output (V), derived from irradiance.                                |
| **current**         | Current output (A), varies with irradiance and panel health.                |
| **module_temperature** | Temperature of the panel surface (°C), distinct from ambient air.        |
| **cloud_coverage**  | Sky coverage by clouds (%), reduces irradiance reaching panel.              |
| **wind_speed**      | Wind speed (m/s), helps in cooling panels, affects temperature.             |
| **pressure**        | Atmospheric pressure at panel location (hPa).                              |
| **string_id**       | Identifier for string/group of panels (e.g., A1, B2).                       |
| **error_code**      | Diagnostic error codes from panel logs (e.g., E00, E01, E02).               |
| **installation_type** | Type of mounting setup – fixed, tracking, or dual-axis.                   |
| **efficiency**      | **Target variable** – final energy output efficiency of the panel.          |

---

## ⚙️ Installation & Setup

### 1. Clone the repository
```bash
git clone https://github.com/SanjilSaurav/Solar-Panel-Efficiency-Prediction.git
cd Solar-Panel-Efficiency-Prediction
```
### 2. Create a virtual environment (optional but recommended)
```bash
python -m venv venv
source venv/bin/activate    # On Linux/Mac
venv\Scripts\activate       # On Windows
```
### 3. Install dependencies
```bash
pip install -r requirements.txt
```
## 🚀 Usage
### 1. Explore Data & Train Model
You can use the notebook for exploration and training:
```bash
jupyter notebook zelestra.ipynb
```
### 2. Run the Application

Start the prediction service (Flask/FastAPI-based, depending on implementation):
```bash
python app.py
```
This will:

- Load the trained model from artifacts/

- Accept input (CSV or API request)

- Output predictions into submission_result.csv

### 3. Predict from Test Data

Place your test data in test.csv and run the application. Predictions will be saved in submission_result.csv.

## 📥 Example Prediction
### Sample Input (test.csv row):
```
id,temperature,irradiance,humidity,panel_age,maintenance_count,soiling_ratio,voltage,current,module_temperature,cloud_coverage,wind_speed,pressure,string_id,error_code,installation_type
101,32.5,820,45,3,1,0.12,36.2,5.4,40.1,25,3.2,1012,A1,E00,fixed
```
### Sample Output (submission_result.csv):
```
id,efficiency
101,0.85
```
## 🛠️ Tech Stack
- Python 3.x
- CatBoost – Gradient Boosting library
- Pandas / NumPy – Data manipulation
- Matplotlib / Seaborn – Visualization
- Flask / FastAPI (via app.py) – Model serving

## 📈 Results
- Trained a CatBoost model on solar panel data.
- Predictions stored in submission_result.csv.
- Pipeline can be extended with:
  - Hyperparameter tuning
  - Feature engineering
  - Deployment on cloud services
 
## 👤 Author
Saurav Kumar
